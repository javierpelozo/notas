'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @module Mongo-DB
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

/**
 * NPM requirements
 */


var _mongodb = require('mongodb');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Shared database connection
 */
var database = null;

/**
 * Default configuration
 */
var config = {
  minSkip: 0,
  maxLimit: 1000,
  sortLastID: {
    _id: -1
  }
};

var _class = function () {

  /**
   * Mongo-DB constructor.
   * @param {string} url - connnection string
   * @param {string} collection - collection name
   * @param {boolean} id - true for collections that use autogeneration of the _id
   */

  function _class(url, collection, id) {
    _classCallCheck(this, _class);

    this.url = url;
    this.collection = collection;

    if (id) {
      this.objectid = _mongodb.ObjectID;
    }
  }

  /**
   * Obtains or creates a connection, and resolves to the current collection
   * @return {object} a promise with a pointer to the collection connection.
   */


  _createClass(_class, [{
    key: 'connect',
    value: function connect() {
      var _this = this;

      if (database && database.databaseName !== undefined) {
        return this.getCollection();
      }

      return _mongodb.MongoClient.connect(this.url).then(function (data) {
        database = data;
        database.on('close', _this.onClose);
        database.on('error', _this.onError);
        return _this.getCollection();
      }).catch(function (error) {
        throw new Error(error);
      });
    }
  }, {
    key: 'getCollection',
    value: function getCollection() {
      var _this2 = this;

      return new _bluebird2.default(function (resolve) {
        var collection = database.collection(_this2.collection);
        return resolve(collection);
      });
    }
  }, {
    key: 'onClose',
    value: function onClose() {
      console.warn('Closing connection!');
      database = null;
    }
  }, {
    key: 'onError',
    value: function onError(error) {
      console.error(error);
    }

    /**
     * Finds documents in current collection
     * @param {Object} query - MongoDB query.
     * @return {Object} a promise with the resulting array.
     */

  }, {
    key: 'find',
    value: function find() {
      var query = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var proj = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var skip = arguments.length <= 2 || arguments[2] === undefined ? config.minSkip : arguments[2];

      var _this3 = this;

      var limit = arguments.length <= 3 || arguments[3] === undefined ? config.maxLimit : arguments[3];
      var sort = arguments.length <= 4 || arguments[4] === undefined ? config.sortLastID : arguments[4];

      return new _bluebird2.default(function (respond, reject) {
        _this3.connect().then(function (collection) {
          _this3.fixQueryID(query);
          collection.find(query).skip(skip).limit(limit).project(proj).sort(sort).toArray(function (error, data) {
            if (error) {
              reject(error);
            } else {
              respond(data);
            }
          });
        }).catch(function (error) {
          return reject(error);
        });
      });
    }

    /**
     * Finds one document in current collection
     * @param {Object} query - MongoDB query.
     * @return {Object} a promise with the resulting array.
     */

  }, {
    key: 'findOne',
    value: function findOne(query, proj) {
      var _this4 = this;

      return this.connect().then(function (collection) {
        _this4.fixQueryID(query);
        var projection = proj || {};
        return collection.findOne(query, projection);
      });
    }

    /**
     * Inserts a document in current collection
     * @param {Object} document - the document to be inserted.
     * @return {Object} a promise with the operation result.
     */

  }, {
    key: 'insert',
    value: function insert(document) {
      return this.connect().then(function (collection) {
        return collection.insert(document);
      });
    }

    /**
     * Inserts documents into the current collection
     * @param {Object} documents - the documents to be inserted.
     * @return {Object} a promise with the operation result.
     */

  }, {
    key: 'insertMany',
    value: function insertMany(documents) {
      return this.connect().then(function (collection) {
        return collection.insertMany(documents);
      });
    }

    /**
     * Updates a document in current collection
     * @param {Object} query - the query to find the documents will be affected.
     * @param {Object} document - the object witha a document replace or instructions to apply
     * @return {Object} a promise with the operation result.
     */

  }, {
    key: 'update',
    value: function update(query, document) {
      var _this5 = this;

      return this.connect().then(function (collection) {
        _this5.fixQueryID(query);
        return collection.update(query, document);
      });
    }

    /**
     * Deletes documents in current collection
     * @param {Object} query - the query to find the documents that will be deleted.
     * @return {Object} a promise with the operation result.
     */

  }, {
    key: 'remove',
    value: function remove(query) {
      var _this6 = this;

      return this.connect().then(function (collection) {
        _this6.fixQueryID(query);
        return collection.remove(query);
      });
    }

    /**
     * Executes an aggregation framework query
     * @param {Object} query - the query steps to be executed.
     * @return {Object} a promise with the resulting array.
     */

  }, {
    key: 'aggregate',
    value: function aggregate(query) {
      var _this7 = this;

      return this.connect().then(function (collection) {
        _this7.fixQueryID(query);
        return collection.aggregate(query).toArray();
      });
    }

    /**
     * Counts how many documents are in current collection
     * @return {Object} a promise with the operation result.
     */

  }, {
    key: 'count',
    value: function count() {
      return this.connect().then(function (collection) {
        return collection.count();
      });
    }

    /**
     * Counts how many documents satisfy a query in current collection
     * @param {Object} query - the query steps to be executed.
     * @return {Object} a promise with the operation result.
     */

  }, {
    key: 'countByQuery',
    value: function countByQuery(query) {
      var _this8 = this;

      return this.connect().then(function (collection) {
        _this8.fixQueryID(query);
        return collection.find(query).count();
      });
    }

    /**
     * Adds a index on a specific field
     * @param {String} index - name of the field.
     * @param {Object} options - options for index.
     * @return {Object} a promise with the operation result.
     */

  }, {
    key: 'createIndex',
    value: function createIndex(index, options) {
      return this.connect().then(function (collection) {
        return collection.createIndex(index, options);
      });
    }

    /**
     * Uses ObjectId when collection requires it, changing _id
     * @param {Object} query - the query with an _id of type string, number...
     * @return {Object} a promise with the resulting array.
     */

  }, {
    key: 'fixQueryID',
    value: function fixQueryID(query) {
      if (this.objectid && query && query._id) {
        query._id = new this.objectid(query._id);
      }
    }
  }]);

  return _class;
}();

exports.default = _class;